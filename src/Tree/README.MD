## Tree
  树是n个结点的集合，集合中有一个称为根(root)的特殊结点，在根结点下分布着一些互不相交的集合，每一个集合又是一个树，这些树称为根结点的子树。    

## 二叉树
  1.在二叉树中，第i层的结点总数最多为2^(i-1)个结点。    
    证： 使用数学归纳法，i = 1时， 2^(i-1) = 2^0 = 1,命题成立。    
        假设1<=j<i时，j的结点为 2^j-1。证明j=i时，命题成立。    
        档j=i-1时，结点数为2^(i-2)。由于二叉树的每个结点至多有2个结点，所以第i层上的最大结点数为j上的结点数*2,即2^(i-2)*2 = 2^(j-1)。    


  2.深度为k的二叉树最多有2^k-1个结点，最少有k个结点。    
      证： 根据性质1,深度为k的二叉树的结点总数         
          S = 2^0 + 2^1 +...+ 2^(k-1)        
          所以 2S = 2^1 + 2^2 +...+ 2^k    
          所以 S = 2S-S= 2^k -1    
  3.对于一个二叉树，如果其叶结点树为n0,,度为1的结点总数为n1,而度为2的结点总数为n2,则n0=n2+1。    
        证： 总数 n = n0+n1+n2,设分支数为B。    
            因 除根结点外，每个结点都对应一个分支，故总结点数 n = B+1。    
            又 度为1的结点的分支数为 n1*1,度为2的结点的分支数为 n2*2,故 B = n1*1 + n2*2。    
            所以 n = n0+n1+n2 = B+1 = n1+2n2+1 => n0 = n2+1    
  4.具有n个结点的完全二叉树的深度k为[log2n]+1。    
  5.有n个结点的完全二叉树如果用顺序结构存储，则对任意结点i，有如下关系：    
    (1)如果i!=1,则其父结点的编号为i/2;    
    (2)如果2*i<=n,则其左子树根结点的编号为2*i,若2*n>n，则无左子树;    
    (3)如果2*i+1<=n,则其右子树根结点的编号为2*i+1;若2*i+1>n,则无右子树;    


##二叉树的遍历
  1.前序遍历(DLR)：先访问根结点，再按前序遍历左子树，后遍历右子树。   
  2.中序遍历(LDR)：先按中序遍历左子树，再访问根结点，最后中序遍历右子树。    
  3.后续遍历(LRD)：先后序遍历左子树，再后序遍历右子树，最后访问根结点。

##编译示例：
  gcc ChainBinTree.c BinTreeExample.c -o BinTreeExample.out     

  ./BinTreeExample.out    
