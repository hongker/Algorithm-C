## Tree
  树是n个结点的集合，集合中有一个称为根(root)的特殊结点，在根结点下分布着一些互不相交的集合，每一个集合又是一个树，这些树称为根结点的子树。    

## 二叉树
  1.在二叉树中，第i层的结点总数最多为2^(i-1)个结点。    
    证： 使用数学归纳法，i = 1时， 2^(i-1) = 2^0 = 1,命题成立。    
        假设1<=j<i时，j的结点为 2^j-1。证明j=i时，命题成立。    
        档j=i-1时，结点数为2^(i-2)。由于二叉树的每个结点至多有2个结点，所以第i层上的最大结点数为j上的结点数*2,即2^(i-2)*2 = 2^(j-1)。    


  2.深度为k的二叉树最多有2^k-1个结点，最少有k个结点。    
      证： 根据性质1,深度为k的二叉树的结点总数         
          S = 2^0 + 2^1 +...+ 2^(k-1)        
          所以 2S = 2^1 + 2^2 +...+ 2^k    
          所以 S = 2S-S= 2^k -1    
  3.对于一个二叉树，如果其叶结点树为n0,,度为1的结点总数为n1,而度为2的结点总数为n2,则n0=n2+1。    
        证： 总数 n = n0+n1+n2,设分支数为B。    
            因 除根结点外，每个结点都对应一个分支，故总结点数 n = B+1。    
            又 度为1的结点的分支数为 n1*1,度为2的结点的分支数为 n2*2,故 B = n1*1 + n2*2。    
            所以 n = n0+n1+n2 = B+1 = n1+2n2+1 => n0 = n2+1    
  4.具有n个结点的完全二叉树的深度k为[log2n]+1。    
  5.有n个结点的完全二叉树如果用顺序结构存储，则对任意结点i，有如下关系：    
    (1)如果i!=1,则其父结点的编号为i/2;    
    (2)如果2*i<=n,则其左子树根结点的编号为2*i,若2*n>n，则无左子树;    
    (3)如果2*i+1<=n,则其右子树根结点的编号为2*i+1;若2*i+1>n,则无右子树;    


##二叉树的遍历
  1.前序遍历(DLR)：先访问根结点，再按前序遍历左子树，后遍历右子树。   
  2.中序遍历(LDR)：先按中序遍历左子树，再访问根结点，最后中序遍历右子树。    
  3.后续遍历(LRD)：先后序遍历左子树，再后序遍历右子树，最后访问根结点。

##最优二叉树(赫夫曼树)
  1.结点的权：根据实际应用中各结点的重要性，赋予各结点一个数，数值大的表示该结点重要性大，这个数值称为结点的权。    
  2.路径：树中一个结点到另一个结点之间的分支，称为两个结点之间的路径。   
  3.路径长度：一个路径上的分支数量称为路径长度。    
  4.树的路径长度：从树的根结点到每个结点的路径长度之和。在结点数目相同的二叉树中，完全二叉树的路径长度最短。    
  5.结点的带权路径长度：若结点是带权的，还可以定义结点的带权路径长度，就是从该结点到根结点的路径长度与该结点的权的乘积。    
  6.树的带权路径长度：树中所有带权结点的路径长度之和就是树的带权路径长度，一般采用WPL(Weighted Path Length)来表示。    


##编译示例：
  gcc ChainBinTree.c BinTreeExample.c -o BinTreeExample.out     
  ./BinTreeExample.out    

  gcc HuffmanTree.c -o HuffmanTree.out    
  ./HuffmanTree.out   
